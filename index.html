<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SaturnPlay</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Inter', sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Lighter, cleaner glass panel */
        .glass-panel {
            background: rgba(15, 15, 25, 0.4);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        
        /* Specific transparent style for the combined panel to look like "one square" */
        .control-square {
            background: rgba(10, 10, 15, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* Richer Space Background */
            background-color: #020205;
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(20, 10, 30, 0.3) 0%, transparent 60%),
                radial-gradient(circle at 10% 20%, rgba(6, 182, 212, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(219, 39, 119, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 10%, rgba(76, 29, 149, 0.2) 0%, transparent 30%),
                radial-gradient(circle at 50% 50%, transparent 40%, #000000 100%);
            background-blend-mode: screen;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .interactive-element {
            pointer-events: auto;
        }

        .input_video { 
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            z-index: -1;
        }

        .output_canvas {
            transform: scaleX(-1); 
        }
        
        .loader {
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            border-top: 2px solid #a855f7;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .btn-pulse { animation: scanner 2s infinite; }
        @keyframes scanner {
            0% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(168, 85, 247, 0); }
            100% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0); }
        }

        /* Smaller, tighter buttons */
        .option-btn {
            transition: all 0.3s ease;
            opacity: 0.5;
            position: relative;
            width: 20px; 
            height: 20px;
        }
        .option-btn.active {
            opacity: 1;
            transform: scale(1.1);
            border-color: #a855f7;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.4);
        }
        /* Tooltip style */
        .option-btn::after {
            content: attr(title);
            position: absolute;
            right: 28px; 
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 100;
        }
        .option-btn:hover::after {
            opacity: 1;
        }
        
        #scatter-text {
            opacity: 0;
            transition: opacity 0.2s ease;
            color: #22d3ee; 
            font-weight: bold;
            text-shadow: 0 0 5px rgba(34, 211, 238, 0.5);
        }

        /* --- UI Hiding Logic --- */
        .hideable-element {
            transition: opacity 0.5s ease, transform 0.5s ease;
            opacity: 1;
            transform: scale(1);
        }

        .ui-minimal-mode .hideable-element {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            .mobile-hide { display: none; }
        }
        
        #theme-container::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer" class="flex flex-col justify-between p-3 safe-area-inset">
        
        <!-- Top UI Area -->
        <div class="flex justify-between items-start w-full">
            
            <!-- TOP LEFT: Info / Hints (No purple border) -->
            <div class="glass-panel rounded-xl p-3 text-white max-w-[160px] interactive-element hideable-element">
                <div class="mb-2">
                    <h1 class="text-xs font-bold text-white/90 uppercase tracking-widest border-b border-white/10 pb-1">
                        Controls
                    </h1>
                </div>
                
                <div class="text-[9px] text-gray-300 space-y-1 font-medium tracking-wide leading-tight">
                    <div class="flex justify-between items-center">
                        <span class="opacity-70">‚úä Fist</span>
                        <span id="scatter-text" class="text-[9px]">SCATTER</span>
                    </div>
                    <div class="flex items-center gap-1"><span class="opacity-70">üñê Open</span> <span>Assemble</span></div>
                    <div class="flex items-center gap-1"><span class="opacity-70">‚Üî Dist</span> <span>Zoom</span></div>
                </div>
            </div>

            <!-- TOP RIGHT: Unified Controls Stack -->
            <div class="flex flex-col gap-3 items-end">
                
                <!-- 1. Toggle Button -->
                <button id="ui-toggle-btn" class="interactive-element w-8 h-8 rounded-full bg-black/40 border border-white/20 text-white flex items-center justify-center hover:bg-purple-600/50 transition-all backdrop-blur-md z-50">
                    <svg id="eye-open" xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                    <svg id="eye-closed" xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />
                    </svg>
                </button>

                <!-- 2. Camera (Direct, no extra wrapper outline) -->
                <div class="relative w-24 h-16 bg-black rounded-lg overflow-hidden border border-white/20 shadow-lg interactive-element">
                    <video class="input_video" playsinline webkit-playsinline></video>
                    <canvas class="output_canvas absolute top-0 left-0 w-full h-full object-cover opacity-90"></canvas>
                    
                    <div id="start-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-60 z-20 cursor-pointer backdrop-blur-sm">
                        <button id="start-btn" class="btn-pulse bg-purple-600 hover:bg-purple-500 text-white text-[9px] font-bold py-1 px-3 rounded-full transition border border-purple-400">
                            LINK
                        </button>
                    </div>
                    <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80 hidden"><div class="loader"></div></div>
                    <div id="error-overlay" class="absolute inset-0 flex flex-col items-center justify-center bg-red-900 bg-opacity-95 hidden p-1 text-center z-30">
                        <p class="text-[8px] font-bold text-white">Error</p>
                    </div>
                </div>

                <!-- 3. Unified Control Square (Form + Energy) -->
                <div class="control-square rounded-xl p-2.5 interactive-element flex flex-col gap-2 items-center hideable-element">
                    
                    <!-- Shapes Grid -->
                    <div class="flex flex-col items-center">
                        <div class="grid grid-cols-3 gap-1.5" id="shape-buttons">
                            <button class="option-btn active rounded bg-gradient-to-br from-blue-500 to-purple-500" data-shape="saturn" title="Saturn"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-green-400 to-blue-500" data-shape="cube" title="Cube"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-orange-500 to-amber-600" data-shape="sphere" title="Sphere"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-pink-500 to-rose-500" data-shape="vortex" title="Vortex"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-yellow-400 to-orange-500" data-shape="torus" title="Torus"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-indigo-400 to-purple-600" data-shape="dna" title="DNA"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-cyan-400 to-blue-600" data-shape="atom" title="Atom"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-amber-300 to-orange-600" data-shape="hourglass" title="Hourglass"></button>
                            <button class="option-btn rounded bg-gradient-to-br from-pink-400 to-rose-600" data-shape="ribbon" title="Ribbon"></button>
                        </div>
                        <div id="current-shape-label" class="text-[8px] text-purple-300 font-medium mt-1">Saturn</div>
                    </div>

                    <!-- Divider -->
                    <div class="w-full h-px bg-white/10"></div>

                    <!-- Energy Row -->
                    <div class="flex flex-col items-center w-full">
                        <div class="flex flex-wrap justify-center gap-1.5" id="theme-container"></div>
                        <div id="current-theme-label" class="text-[8px] text-purple-300 font-medium mt-1">Cosmic</div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Bottom Right Status -->
        <div class="flex justify-end pointer-events-none">
            <div class="glass-panel rounded-lg px-2 py-1 text-right opacity-80 scale-90 origin-bottom-right border-r-2 border-purple-500 hideable-element">
                <div class="flex items-center gap-2">
                    <span id="status-indicator" class="w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse"></span>
                    <span id="status-text" class="text-[9px] text-gray-400 uppercase tracking-wider">Standby</span>
                </div>
                <div class="text-[10px] font-mono text-white font-bold flex items-center justify-end gap-2">
                    <span id="zoom-val">100%</span> <span id="track-dot" class="w-1.5 h-1.5 bg-red-500 rounded-full"></span>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- Constants ---
    const CONSTANTS = {
        // Performance
        PARTICLE_COUNT_DESKTOP: 12000,
        PARTICLE_COUNT_MOBILE: 8000, 
        STAR_COUNT_SMALL: 2000,
        STAR_COUNT_LARGE: 800,
        
        // Rendering
        BASE_SIZE: 18,
        ZOOM_SENSITIVITY: 3.5,
        BASE_HAND_SIZE: 0.2,
        FIST_THRESHOLD: 0.5,
        LERP_SPEED: 0.15,
        SHAPE_MORPH_SPEED: 0.15,
        HISTORY_SIZE: 3,
        STABILITY_THRESHOLD: 0.015,
        
        // Camera
        INITIAL_CAMERA_Z: 80,
        FOG_DENSITY: 0.008,
        
        // Zoom limits
        MIN_ZOOM: 0.2,
        MAX_ZOOM: 10.0, 
        
        // Scene dimensions
        SCENE_BOUNDS: 1200,
        STARFIELD_BOUNDS_SMALL: 1200,
        STARFIELD_BOUNDS_LARGE: 800
    };

    // --- Config & Themes ---
    const THEMES = [
        { name: 'Cosmic', core: '#a855f7', ring: '#3b82f6' }, 
        { name: 'Rose',   core: '#fb7185', ring: '#ffe4e6' }, 
        { name: 'Berry',  core: '#db2777', ring: '#9333ea' }, 
        { name: 'Sunset', core: '#f59e0b', ring: '#e11d48' }, 
        { name: 'Ocean',  core: '#06b6d4', ring: '#1d4ed8' }, 
        { name: 'Mint',   core: '#34d399', ring: '#059669' }, 
        { name: 'Gold',   core: '#fbbf24', ring: '#d97706' } 
    ];
    
    let currentTheme = THEMES[0];
    let currentShape = 'saturn';
    let particleCount = window.innerWidth <= 768 ? CONSTANTS.PARTICLE_COUNT_MOBILE : CONSTANTS.PARTICLE_COUNT_DESKTOP;

    // --- State Management ---
    class AppState {
        constructor() {
            this.targetScale = 1;
            this.currentScale = 1;
            this.targetScatter = 0;
            this.currentScatter = 0;
            this.isExploded = false;
            this.rotY = 0;
            this.rotX = 0.2;
            this.targetRotY = 0;
            this.targetRotX = 0.2;
            this.handDetected = false;
            this.xHistory = [];
            this.yHistory = [];
            this.lastStableX = 0.5;
            this.lastStableY = 0.5;
        }
        
        resetOnHandLoss() {
            this.handDetected = false;
            this.isExploded = false;
            this.targetScatter = 0;
            this.targetScale = 1;
            this.xHistory = [];
            this.yHistory = [];
            this.targetRotY = this.rotY;
            this.targetRotX = this.rotX * 0.9 + 0.2 * 0.1;
        }
    }

    const state = new AppState();

    // --- Resource Management ---
    class ResourceManager {
        constructor() {
            this.texture = null;
            this.resources = [];
        }
        
        createTexture() {
            if (this.texture) return this.texture;
            
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64;
            const cy = 64;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.15, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.fill();
            
            this.texture = new THREE.Texture(canvas);
            this.texture.needsUpdate = true;
            this.resources.push(this.texture);
            
            return this.texture;
        }
        
        dispose() {
            this.resources.forEach(resource => {
                if (resource.dispose) resource.dispose();
                if (resource.geometry) resource.geometry.dispose();
                if (resource.material) {
                    if (Array.isArray(resource.material)) {
                        resource.material.forEach(m => m.dispose());
                    } else {
                        resource.material.dispose();
                    }
                }
            });
            this.resources = [];
            this.texture = null;
        }
    }

    const resourceManager = new ResourceManager();

    // --- Three.js Scene Management ---
    class SceneManager {
        constructor() {
            this.container = document.getElementById('canvas-container');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = null;
            this.particleSystem = null;
            this.stars2 = null;
            this.init();
        }
        
        init() {
            this.scene.fog = new THREE.FogExp2(0x0a0518, CONSTANTS.FOG_DENSITY);
            this.camera.position.z = CONSTANTS.INITIAL_CAMERA_Z;
            this.camera.position.y = 0;
            this.camera.lookAt(0, 0, 0);
            
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                alpha: true, 
                powerPreference: "high-performance" 
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.container.appendChild(this.renderer.domElement);
            
            resourceManager.resources.push(this.scene, this.camera, this.renderer);
        }
        
        createStarfield() {
            const starGeo1 = new THREE.BufferGeometry();
            const starPos1 = [];
            const starSizes1 = [];
            
            for(let i = 0; i < CONSTANTS.STAR_COUNT_SMALL; i++) {
                starPos1.push(
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_SMALL,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_SMALL,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_SMALL
                );
                starSizes1.push(Math.random() * 1.5);
            }
            
            starGeo1.setAttribute('position', new THREE.Float32BufferAttribute(starPos1, 3));
            starGeo1.setAttribute('size', new THREE.Float32BufferAttribute(starSizes1, 1));
            
            const starMat1 = new THREE.PointsMaterial({
                color: 0xa0a0ff,
                size: 1.0,
                map: resourceManager.createTexture(),
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            this.scene.add(new THREE.Points(starGeo1, starMat1));
            resourceManager.resources.push(starGeo1, starMat1);
            
            const starGeo2 = new THREE.BufferGeometry();
            const starPos2 = [];
            const starSizes2 = [];
            
            for(let i = 0; i < CONSTANTS.STAR_COUNT_LARGE; i++) {
                starPos2.push(
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_LARGE,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_LARGE,
                    (Math.random() - 0.5) * CONSTANTS.STARFIELD_BOUNDS_LARGE
                );
                starSizes2.push(0.8 + Math.random() * 2.0);
            }
            
            starGeo2.setAttribute('position', new THREE.Float32BufferAttribute(starPos2, 3));
            starGeo2.setAttribute('size', new THREE.Float32BufferAttribute(starSizes2, 1));
            
            const starMat2 = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.0,
                map: resourceManager.createTexture(),
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            this.stars2 = new THREE.Points(starGeo2, starMat2);
            this.scene.add(this.stars2);
            resourceManager.resources.push(starGeo2, starMat2, this.stars2);
        }
        
        createParticleSystem() {
            const particlesGeometry = new THREE.BufferGeometry();
            const currentPositions = new Float32Array(particleCount * 3);
            const targetPositions = new Float32Array(particleCount * 3);
            const scatterVectors = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for(let i = 0; i < particleCount; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 40 + Math.random() * 60;
                scatterVectors[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                scatterVectors[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                scatterVectors[i * 3 + 2] = r * Math.cos(phi);
                sizes[i] = 0.8 + Math.random() * 1.0;
            }
            
            const initData = ShapeGenerator.generate('saturn', particleCount, currentTheme);
            targetPositions.set(initData.pos);
            currentPositions.set(initData.pos.slice());
            colors.set(initData.col);
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 1.2,
                map: resourceManager.createTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.NormalBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            
            this.particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            this.scene.add(this.particleSystem);
            
            this.particlesGeometry = particlesGeometry;
            this.particlesMaterial = particlesMaterial;
            this.currentPositions = currentPositions;
            this.targetPositions = targetPositions;
            this.scatterVectors = scatterVectors;
            this.colors = colors;
            
            resourceManager.resources.push(particlesGeometry, particlesMaterial, this.particleSystem);
            
            return {
                geometry: particlesGeometry,
                material: particlesMaterial,
                system: this.particleSystem,
                currentPositions,
                targetPositions,
                scatterVectors,
                colors
            };
        }
        
        resize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    // --- Shape Generation ---
    class ShapeGenerator {
        static generate(type, particleCount, theme) {
            const newPos = new Float32Array(particleCount * 3);
            const newCol = new Float32Array(particleCount * 3);
            const c1 = new THREE.Color(theme.core);
            const c2 = new THREE.Color(theme.ring);
            
            for(let i = 0; i < particleCount; i++) {
                let x, y, z, r, g, b;
                const ix = i * 3;
                
                switch(type) {
                    case 'saturn':
                        if (i < particleCount * 0.4) {
                            const phi = Math.acos(-1 + (2 * i) / (particleCount * 0.4));
                            const theta = Math.sqrt((particleCount * 0.4) * Math.PI) * phi;
                            const rad = CONSTANTS.BASE_SIZE + (Math.random() - 0.5);
                            x = rad * Math.cos(theta) * Math.sin(phi);
                            y = rad * Math.sin(theta) * Math.sin(phi);
                            z = rad * Math.cos(phi);
                            r = c1.r; g = c1.g; b = c1.b;
                        } else {
                            const rad = THREE.MathUtils.randFloat(26, 52);
                            const theta = Math.random() * Math.PI * 2;
                            x = rad * Math.cos(theta);
                            z = rad * Math.sin(theta);
                            y = (Math.random() - 0.5) * 0.5;
                            const mix = (rad - 26) / (52 - 26);
                            const c = new THREE.Color().lerpColors(c1, c2, mix);
                            r = c.r; g = c.g; b = c.b;
                        }
                        break;
                        
                    case 'cube':
                        const side = CONSTANTS.BASE_SIZE * 1.5;
                        const face = Math.floor(Math.random() * 6);
                        const u = (Math.random() - 0.5) * 2 * side;
                        const v = (Math.random() - 0.5) * 2 * side;
                        if(face === 0){x = side; y = u; z = v;}
                        else if(face === 1){x = -side; y = u; z = v;}
                        else if(face === 2){x = u; y = side; z = v;}
                        else if(face === 3){x = u; y = -side; z = v;}
                        else if(face === 4){x = u; y = v; z = side;}
                        else{x = u; y = v; z = -side;}
                        x += (Math.random() - 0.5);
                        y += (Math.random() - 0.5);
                        z += (Math.random() - 0.5);
                        const mix = Math.min((Math.abs(u) + Math.abs(v)) / (side * 2), 1);
                        const c = new THREE.Color().lerpColors(c1, c2, mix);
                        r = c.r; g = c.g; b = c.b;
                        break;
                        
                    case 'sphere':
                        const phi = Math.acos(-1 + (2 * i) / particleCount);
                        const theta = Math.sqrt(particleCount * Math.PI) * phi;
                        const rad = CONSTANTS.BASE_SIZE * 1.5;
                        x = rad * Math.cos(theta) * Math.sin(phi);
                        y = rad * Math.sin(theta) * Math.sin(phi);
                        z = rad * Math.cos(phi);
                        const sphereColor = new THREE.Color().lerpColors(c1, c2, Math.abs(y / rad));
                        r = sphereColor.r; g = sphereColor.g; b = sphereColor.b;
                        break;
                        
                    case 'vortex':
                        const branchAngle = (i % 3) * ((2 * Math.PI) / 3);
                        const radVortex = Math.random() * 50;
                        const angle = branchAngle + radVortex * 0.1;
                        x = Math.cos(angle) * radVortex;
                        z = Math.sin(angle) * radVortex;
                        y = (Math.random() - 0.5) * (10 - radVortex * 0.15);
                        const vortexColor = new THREE.Color().lerpColors(c1, c2, radVortex / 50);
                        r = vortexColor.r; g = vortexColor.g; b = vortexColor.b;
                        break;
                        
                    case 'torus':
                        const uTorus = Math.random() * Math.PI * 2;
                        const vTorus = Math.random() * Math.PI * 2;
                        x = (30 + 10 * Math.cos(vTorus)) * Math.cos(uTorus);
                        z = (30 + 10 * Math.cos(vTorus)) * Math.sin(uTorus);
                        y = 10 * Math.sin(vTorus);
                        const torusColor = new THREE.Color().lerpColors(c1, c2, Math.abs(Math.sin(uTorus * 2)));
                        r = torusColor.r; g = torusColor.g; b = torusColor.b;
                        break;
                        
                    case 'dna':
                        const h = (i / particleCount) * 80 - 40;
                        const angleDNA = h * 0.2;
                        const radDNA = 12;
                        const offset = (i % 2 === 0) ? 0 : Math.PI;
                        x = Math.cos(angleDNA + offset) * radDNA + (Math.random() - 0.5) * 2;
                        z = Math.sin(angleDNA + offset) * radDNA + (Math.random() - 0.5) * 2;
                        y = h;
                        const dnaColor = (i % 2 === 0) ? c1 : c2;
                        r = dnaColor.r; g = dnaColor.g; b = dnaColor.b;
                        break;
                        
                    case 'atom':
                        if(i < particleCount * 0.2) {
                            const phiAtom = Math.acos(-1 + (2 * i) / (particleCount * 0.2));
                            const thetaAtom = Math.sqrt((particleCount * 0.2) * Math.PI) * phiAtom;
                            const radAtom = CONSTANTS.BASE_SIZE * 0.4 + (Math.random() - 0.5);
                            x = radAtom * Math.cos(thetaAtom) * Math.sin(phiAtom);
                            y = radAtom * Math.sin(thetaAtom) * Math.sin(phiAtom);
                            z = radAtom * Math.cos(phiAtom);
                            r = c1.r; g = c1.g; b = c1.b;
                        } else {
                            const ringPart = (i - particleCount * 0.2);
                            const ringTotal = particleCount * 0.8;
                            const ringIndex = Math.floor(ringPart / (ringTotal / 3));
                            const rad = CONSTANTS.BASE_SIZE * 3.0;
                            const theta = Math.random() * Math.PI * 2;
                            const rt = (Math.random() - 0.5) * 1.5;
                            if(ringIndex === 0){
                                x = rad * Math.cos(theta);
                                y = rad * Math.sin(theta);
                                z = rt;
                                const rot = Math.PI / 3;
                                const yn = y * Math.cos(rot) - z * Math.sin(rot);
                                const zn = y * Math.sin(rot) + z * Math.cos(rot);
                                y = yn;
                                z = zn;
                            } else if(ringIndex === 1){
                                x = rad * Math.cos(theta);
                                y = rad * Math.sin(theta);
                                z = rt;
                                const rot = -Math.PI / 3;
                                const yn = y * Math.cos(rot) - z * Math.sin(rot);
                                const zn = y * Math.sin(rot) + z * Math.cos(rot);
                                y = yn;
                                z = zn;
                            } else {
                                x = rad * Math.cos(theta);
                                z = rad * Math.sin(theta);
                                y = rt;
                            }
                            const atomColor = new THREE.Color().lerpColors(c1, c2, Math.random() * 0.5 + 0.5);
                            r = atomColor.r; g = atomColor.g; b = atomColor.b;
                        }
                        break;
                        
                    case 'hourglass':
                        const half = particleCount / 2;
                        const hHour = CONSTANTS.BASE_SIZE * 3;
                        const w = CONSTANTS.BASE_SIZE * 2.5;
                        let nh, radHour;
                        if(i < half){
                            nh = i / half;
                            y = nh * hHour + 1;
                            radHour = nh * w;
                        } else {
                            nh = (i - half) / half;
                            y = -nh * hHour - 1;
                            radHour = nh * w;
                        }
                        radHour = Math.pow(radHour / w, 1.5) * w;
                        const thetaHour = Math.random() * Math.PI * 2;
                        x = radHour * Math.cos(thetaHour);
                        z = radHour * Math.sin(thetaHour);
                        if(Math.random() > 0.97){
                            x = (Math.random() - 0.5) * 2;
                            z = (Math.random() - 0.5) * 2;
                            y = (Math.random() - 0.5) * hHour * 2;
                        }
                        const hourglassColor = new THREE.Color().lerpColors(c1, c2, radHour / w);
                        r = hourglassColor.r; g = hourglassColor.g; b = hourglassColor.b;
                        break;

                    case 'ribbon':
                        const pKnot = Math.floor(particleCount * 0.1);
                        const pLoop = Math.floor(particleCount * 0.6);
                        
                        if (i < pKnot) {
                            const rKnot = 8;
                            const u = Math.random() * Math.PI * 2;
                            const v = Math.random() * Math.PI;
                            x = rKnot * Math.sin(v) * Math.cos(u);
                            y = rKnot * Math.sin(v) * Math.sin(u);
                            z = (rKnot * 0.6) * Math.cos(v);
                            r = c1.r; g = c1.g; b = c1.b;
                        } else if (i < pKnot + pLoop) {
                            const idx = i - pKnot;
                            const t = (idx / pLoop) * Math.PI * 2;
                            const scale = 40;
                            x = scale * Math.sin(t);
                            y = (scale * 0.5) * Math.sin(2 * t);
                            
                            const thickness = 6;
                            x += (Math.random() - 0.5) * thickness;
                            y += (Math.random() - 0.5) * thickness;
                            z = (Math.random() - 0.5) * 12;
                            
                            const mix = Math.abs(Math.sin(t));
                            const c = new THREE.Color().lerpColors(c1, c2, mix);
                            r = c.r; g = c.g; b = c.b;
                        } else {
                            const idx = i - (pKnot + pLoop);
                            const pTail = particleCount - (pKnot + pLoop);
                            const halfTail = pTail / 2;
                            
                            const isRight = idx >= halfTail;
                            const t = (idx % halfTail) / halfTail;
                            const tailLen = 45;
                            const tailSpread = 25;
                            const side = isRight ? 1 : -1;
                            
                            x = side * (5 + t * tailSpread);
                            y = -5 - (t * tailLen);
                            z = Math.sin(t * Math.PI * 2) * 5;
                            
                            x += (Math.random() - 0.5) * 4;
                            y += (Math.random() - 0.5) * 4;
                            z += (Math.random() - 0.5) * 4;

                            const c = new THREE.Color().lerpColors(c1, c2, t);
                            r = c.r; g = c.g; b = c.b;
                        }
                        break;
                        
                    default:
                        x = y = z = r = g = b = 0;
                }
                
                newPos[ix] = x;
                newPos[ix + 1] = y;
                newPos[ix + 2] = z;
                newCol[ix] = r;
                newCol[ix + 1] = g;
                newCol[ix + 2] = b;
            }
            
            return { pos: newPos, col: newCol };
        }
    }

    // --- UI Management ---
    class UIManager {
        constructor() {
            this.themeContainer = document.getElementById('theme-container');
            this.shapeButtons = document.getElementById('shape-buttons');
            this.currentShapeLabel = document.getElementById('current-shape-label');
            this.currentThemeLabel = document.getElementById('current-theme-label');
            this.zoomVal = document.getElementById('zoom-val');
            this.trackDot = document.getElementById('track-dot');
            this.scatterText = document.getElementById('scatter-text');
            this.loader = document.getElementById('loading-spinner');
            this.startBtn = document.getElementById('start-btn');
            this.startOverlay = document.getElementById('start-overlay');
            this.statusText = document.getElementById('status-text');
            this.statusIndicator = document.getElementById('status-indicator');
            this.uiLayer = document.getElementById('ui-layer');
            this.toggleBtn = document.getElementById('ui-toggle-btn');
            this.eyeOpen = document.getElementById('eye-open');
            this.eyeClosed = document.getElementById('eye-closed');
            
            this.init();
        }
        
        init() {
            this.initThemeButtons();
            this.initShapeButtons();
            this.initVisibilityToggle();
        }
        
        initThemeButtons() {
            THEMES.forEach((theme, index) => {
                const btn = document.createElement('div');
                btn.className = `w-4 h-4 rounded-full cursor-pointer border border-white/20 transition-all ${index === 0 ? 'scale-125 border-white shadow' : ''}`;
                btn.style.background = `linear-gradient(135deg, ${theme.core} 0%, ${theme.ring} 100%)`;
                btn.dataset.theme = theme.name.toLowerCase();
                btn.onclick = () => this.setTheme(theme, btn);
                this.themeContainer.appendChild(btn);
            });
        }
        
        initShapeButtons() {
            const buttons = this.shapeButtons.querySelectorAll('.option-btn');
            buttons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const shape = btn.dataset.shape;
                    this.setShape(shape, btn);
                });
            });
        }

        initVisibilityToggle() {
            this.toggleBtn.onclick = () => {
                this.uiLayer.classList.toggle('ui-minimal-mode');
                const isHidden = this.uiLayer.classList.contains('ui-minimal-mode');
                
                if (isHidden) {
                    this.eyeOpen.classList.add('hidden');
                    this.eyeClosed.classList.remove('hidden');
                } else {
                    this.eyeOpen.classList.remove('hidden');
                    this.eyeClosed.classList.add('hidden');
                }
            };
        }
        
        setTheme(theme, button) {
            currentTheme = theme;
            document.querySelectorAll('#theme-container div').forEach(b => {
                b.classList.remove('scale-125', 'border-white', 'shadow');
            });
            button.classList.add('scale-125', 'border-white', 'shadow');
            this.currentThemeLabel.textContent = theme.name;
            if (sceneManager.particleSystem) {
                updateShapeData();
            }
        }
        
        setShape(shape, button) {
            currentShape = shape;
            document.querySelectorAll('.option-btn').forEach(b => b.classList.remove('active'));
            button.classList.add('active');
            this.currentShapeLabel.textContent = button.title || shape.charAt(0).toUpperCase() + shape.slice(1);
            if (sceneManager.particleSystem) {
                updateShapeData();
            }
        }
        
        updateTracking(status, zoom = null) {
            if (status === 'tracking') {
                this.trackDot.classList.replace('bg-red-500', 'bg-green-500');
            } else {
                this.trackDot.classList.replace('bg-green-500', 'bg-red-500');
            }
            if (zoom !== null) {
                this.zoomVal.textContent = Math.round(zoom * 100) + "%";
            }
        }
        
        updateStatus(status, isError = false) {
            this.statusText.textContent = status;
            if (isError) {
                this.statusIndicator.classList.replace('bg-yellow-400', 'bg-red-400');
            } else if (status === "Connected") {
                this.statusIndicator.classList.replace('bg-yellow-400', 'bg-green-400');
                this.statusIndicator.classList.remove('animate-pulse');
            }
        }
    }

    // --- Hand Tracking ---
    class HandTracker {
        constructor() {
            this.videoElement = document.getElementsByClassName('input_video')[0];
            this.canvasElement = document.getElementsByClassName('output_canvas')[0];
            this.canvasCtx = this.canvasElement.getContext('2d');
            this.hands = null;
            this.cameraUtils = null;
            
            this.init();
        }
        
        init() {
            this.hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            this.hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            this.hands.onResults(this.onResults.bind(this));
            
            this.cameraUtils = new Camera(this.videoElement, {
                onFrame: async () => {
                    await this.hands.send({ image: this.videoElement });
                },
                width: 320,
                height: 240
            });
        }
        
        getWeightedAverage(history) {
            if(history.length === 0) return 0.5;
            let sum = 0, weightSum = 0;
            for(let i = 0; i < history.length; i++) {
                const w = i + 1;
                sum += history[i] * w;
                weightSum += w;
            }
            return sum / weightSum;
        }
        
        onResults(results) {
            if (uiManager.loader.style.display !== 'none') {
                uiManager.loader.style.display = 'none';
                uiManager.updateStatus("Connected");
            }
            
            this.canvasElement.width = results.image.width;
            this.canvasElement.height = results.image.height;
            
            this.canvasCtx.save();
            this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
            this.canvasCtx.drawImage(results.image, 0, 0, this.canvasElement.width, this.canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                state.handDetected = true;
                uiManager.updateTracking('tracking');
                
                drawConnectors(this.canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(168, 85, 247, 0.5)', lineWidth: 2});
                drawLandmarks(this.canvasCtx, landmarks, {color: '#FFFFFF', lineWidth: 1, radius: 2});
                
                const wrist = landmarks[0];
                const midMCP = landmarks[9];
                const handSize = Math.hypot(wrist.x - midMCP.x, wrist.y - midMCP.y);
                let zoom = handSize / CONSTANTS.BASE_HAND_SIZE;
                zoom = Math.max(CONSTANTS.MIN_ZOOM, Math.min(zoom, CONSTANTS.MAX_ZOOM));
                state.targetScale = zoom;
                uiManager.updateTracking('tracking', zoom);
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const openness = pinchDist / handSize;
                
                if (openness < CONSTANTS.FIST_THRESHOLD) {
                    state.isExploded = true;
                    state.targetScatter = 1.0;
                    if(uiManager.scatterText) uiManager.scatterText.style.opacity = 1;
                } else {
                    if (state.isExploded) {
                        const range = 0.6;
                        let val = (openness - CONSTANTS.FIST_THRESHOLD) / range;
                        val = Math.max(0, Math.min(1, val));
                        state.targetScatter = 1.0 - val;
                        if (state.targetScatter < 0.05) {
                            state.isExploded = false;
                            state.targetScatter = 0.0;
                        }
                    } else {
                        state.targetScatter = 0.0;
                        if(uiManager.scatterText) uiManager.scatterText.style.opacity = 0;
                    }
                }
                
                state.xHistory.push(landmarks[9].x);
                state.yHistory.push(landmarks[9].y);
                if(state.xHistory.length > CONSTANTS.HISTORY_SIZE) state.xHistory.shift();
                if(state.yHistory.length > CONSTANTS.HISTORY_SIZE) state.yHistory.shift();
                
                const smoothedX = this.getWeightedAverage(state.xHistory);
                const smoothedY = this.getWeightedAverage(state.yHistory);
                
                const deltaX = Math.abs(smoothedX - state.lastStableX);
                const deltaY = Math.abs(smoothedY - state.lastStableY);
                
                let stableX = state.lastStableX;
                let stableY = state.lastStableY;
                
                if (deltaX > CONSTANTS.STABILITY_THRESHOLD) {
                    state.lastStableX = smoothedX;
                    stableX = smoothedX;
                }
                if (deltaY > CONSTANTS.STABILITY_THRESHOLD) {
                    state.lastStableY = smoothedY;
                    stableY = smoothedY;
                }
                
                const x = stableX;
                const y = stableY;
                state.targetRotY = (0.5 - x) * 4.0;
                state.targetRotX = (0.5 - y) * 4.0;
            } else {
                state.resetOnHandLoss();
                uiManager.updateTracking('lost');
                if(uiManager.scatterText) uiManager.scatterText.style.opacity = 0;
                state.targetRotY += 0.002;
                state.targetRotX = state.rotX * 0.9 + 0.2 * 0.1;
            }
            
            this.canvasCtx.restore();
        }
        
        start() {
            this.cameraUtils.start();
        }
        
        stop() {
            if (this.cameraUtils) {
                this.cameraUtils.stop();
            }
        }
    }

    // --- Global Variables ---
    let sceneManager;
    let handTracker;
    let uiManager;
    let animationId;
    const clock = new THREE.Clock();

    // --- Helper Functions ---
    function updateShapeData() {
        const data = ShapeGenerator.generate(currentShape, particleCount, currentTheme);
        for(let i = 0; i < data.pos.length; i++) {
            sceneManager.targetPositions[i] = data.pos[i];
            sceneManager.colors[i] = data.col[i];
        }
        sceneManager.particlesGeometry.attributes.color.needsUpdate = true;
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        state.currentScale += (state.targetScale - state.currentScale) * CONSTANTS.LERP_SPEED;
        
        if (state.isExploded && state.targetScatter > 0.9) {
            state.currentScatter += (state.targetScatter - state.currentScatter) * 0.05;
        } else {
            state.currentScatter += (state.targetScatter - state.currentScatter) * 0.4;
        }
        
        if (state.handDetected) {
            state.rotY += (state.targetRotY - state.rotY) * CONSTANTS.LERP_SPEED;
            state.rotX += (state.targetRotX - state.rotX) * CONSTANTS.LERP_SPEED;
        } else {
            state.rotY += 0.002;
            state.rotX += (state.targetRotX - state.rotX) * 0.05;
        }
        
        sceneManager.particleSystem.rotation.y = state.rotY;
        sceneManager.particleSystem.rotation.x = state.rotX;
        sceneManager.particleSystem.scale.set(state.currentScale, state.currentScale, state.currentScale);
        sceneManager.particlesMaterial.size = 1.2 + Math.log(Math.max(1, state.currentScale)) * 0.5;
        
        if (sceneManager.stars2) {
            sceneManager.stars2.rotation.y = time * 0.02;
        }
        
        const posAttr = sceneManager.particlesGeometry.attributes.position;
        for(let i = 0; i < particleCount; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;
            
            let cx = sceneManager.currentPositions[ix];
            let cy = sceneManager.currentPositions[iy];
            let cz = sceneManager.currentPositions[iz];
            
            const tx = sceneManager.targetPositions[ix];
            const ty = sceneManager.targetPositions[iy];
            const tz = sceneManager.targetPositions[iz];
            
            cx += (tx - cx) * CONSTANTS.SHAPE_MORPH_SPEED;
            cy += (ty - cy) * CONSTANTS.SHAPE_MORPH_SPEED;
            cz += (tz - cz) * CONSTANTS.SHAPE_MORPH_SPEED;
            
            sceneManager.currentPositions[ix] = cx;
            sceneManager.currentPositions[iy] = cy;
            sceneManager.currentPositions[iz] = cz;
            
            const sx = sceneManager.scatterVectors[ix];
            const sy = sceneManager.scatterVectors[iy];
            const sz = sceneManager.scatterVectors[iz];
            
            const fx = cx + (sx - cx) * state.currentScatter;
            const fy = cy + (sy - cy) * state.currentScatter;
            const fz = cz + (sz - cz) * state.currentScatter;
            
            let noise = 0;
            if (state.currentScatter < 0.1) {
                noise = Math.sin(time * 2 + i) * 0.05;
            }
            
            posAttr.setXYZ(i, fx + noise, fy + noise, fz + noise);
        }
        
        posAttr.needsUpdate = true;
        sceneManager.renderer.render(sceneManager.scene, sceneManager.camera);
    }

    function startApp() {
        sceneManager = new SceneManager();
        uiManager = new UIManager();
        handTracker = new HandTracker();
        sceneManager.createStarfield();
        sceneManager.createParticleSystem();
        animate();
        setupEventListeners();
    }

    function setupEventListeners() {
        uiManager.startBtn.onclick = () => {
            uiManager.startOverlay.style.display = 'none';
            uiManager.loader.style.display = 'flex';
            
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
                .then(stream => {
                    stream.getTracks().forEach(track => track.stop());
                    handTracker.start();
                })
                .catch(error => {
                    console.error('Camera error:', error);
                    uiManager.loader.style.display = 'none';
                    uiManager.updateStatus('Error', true);
                    document.getElementById('error-overlay').style.display = 'flex';
                });
        };
        
        window.addEventListener('resize', () => {
            sceneManager.resize();
        });
        
        window.addEventListener('beforeunload', cleanup);
        window.addEventListener('pagehide', cleanup);
    }

    function cleanup() {
        if (animationId) cancelAnimationFrame(animationId);
        if (handTracker) handTracker.stop();
        resourceManager.dispose();
        if (handTracker && handTracker.videoElement && handTracker.videoElement.srcObject) {
            const stream = handTracker.videoElement.srcObject;
            stream.getTracks().forEach(track => track.stop());
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        try {
            startApp();
        } catch (error) {
            console.error('Failed to initialize app:', error);
            uiManager.updateStatus('Init Failed', true);
        }
    });
</script>
</body>
</html>
